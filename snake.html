<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Super snake game</title>
</head>
<body style="margin: 0; overflow: hidden; ">
  <canvas id="canvas"></canvas>
  <div class="updates"></div>
  <style>
    .updates {
      position: fixed;
      width: 100vw; 
      display: flex;
      top: 36%;
      justify-content: center;
    }

    .canvasBorder {
      border: 1px solid lightgrey;
    }

    canvas {
      border: 1px solid rgb(241, 241, 241);
    }
  </style>
  <script>
    let startText = `<div><h1>SnakeGame</h1><br><br><h1>Play with arrows and/or mouse</h1>
    <br>
    <h1>Push an arrow key or click to start</h1></div>`;
    var updates = document.querySelector('.updates');

    const LEFT = 37;
    const UP = 38;
    const RIGHT = 39;
    const DOWN = 40;

    updates.innerHTML = startText;
    var canvas = document.getElementById('canvas');

    let gameSize = 250;
    let gameGrowSize = 50;
    updateCanvasSize = function(dontGrow) {
      // Check if growing gameSize would extend outside screen
      let spacex = Math.max(0, window.innerWidth - 12 - gameSize);
      let spacey = Math.max(0, window.innerHeight - 12 - gameSize);
      let difx = Math.min(spacex / 2, gameGrowSize / 2);
      let dify = Math.min(spacey / 2, gameGrowSize / 2);
      if(!dontGrow){
        gameSize += gameGrowSize;
      }
      let actualGameHeight = Math.min(gameSize, window.innerHeight - 12);
      let actualGameWidth = Math.min(gameSize, window.innerWidth - 12);
      let topMargin = (window.innerHeight - actualGameHeight)/2 -1;
      let sideMargin = (window.innerWidth - actualGameWidth)/2 -1;
      canvas.style.margin = topMargin + 'px ' + sideMargin + 'px';
      canvas.width = actualGameWidth;
      canvas.height = actualGameHeight;
      return [difx,dify];
    }
    updateCanvasSize();
    var ctx = canvas.getContext('2d');
    let x,y,snake,dx,dy, pl, pr, pu, pd, mx, my,
    snakeColor,foodColor,snakeSize,foodX,
    foodY, growthPerFood, snakeSpeed, snakeSpeedup, squareSize, 
    keys=[], drawing, score, highScore=0, playing, controlWithMouse, 
    mouseMovedSoTurn, mouseMove, xdiff, ydiff, showingMoup,
    enableWrap, precisionAngle, tagertAngle, scoreScreenOn;
    let happySounds = [new Audio('hooray.mp3'), new Audio('myammyam.mp3'), new Audio('woohoo.mp3'),new Audio('yumyum.mp3')];
    let deathSounds = [new Audio('ohno.mp3')];
    let moupSounds = [new Audio('moup.mp3')];
    
    // add keylistener to keep track of latest key pressed
    document.addEventListener('keydown', function(event) {
      controlWithMouse = false;
      keys[event.keyCode] = true;
      if(scoreScreenOn){
        if( event.keyCode === 32 || event.keyCode === 13){
          closeScoreScreen();
        }
      } else if(playing!==true){
        // check if event is space or enter or an arrow key
        if(event.keyCode === 13 || (event.keyCode >=37 && event.keyCode <= 40 ) || event.keyCode === 32){
          updates.style.display="none";
          setup();
        }
      }
    });
    
    document.addEventListener('keyup', function(event) {
      //arrow keys will beprocessed in moveSnake()
      if(event.keyCode <37 && event.keyCode > 40 ){
        keys[event.keyCode] = false;
      }
    });

    getMxMy = function(){
       // find if the mouse is on the canvas, and make offset releative to canvas
       let rect = canvas.getBoundingClientRect();
      if(event.target == canvas){
        mx = event.offsetX;
        my = event.offsetY;
      }else {
        mx = event.pageX - rect.left;
        my = event.pageY - rect.top;
      }
      
      mouseMovedSoTurn = true;
      mouseMove = true;
    }

    // add a mouseMove listener to keep track of mouse position
    document.addEventListener('mousemove', function(event) {
      if(controlWithMouse){     
        getMxMy();
      }
    } );

    // add a mouseDown listener to start the game or activate the mouse control
    document.addEventListener('mousedown', function(event) {
      controlWithMouse = true;
      delete pr;
      delete pu;
      delete pd;
      delete pl;

      getMxMy();

      if(playing!==true){
        updates.style.display="none";
        setup(true);
      }
    });
    
    window.addEventListener('resize', function(event) {
      updateCanvasSize(true);
    } );
    
    function setup() {
      canvas.classList.toggle('canvasBorder');
      gameSize = 250;
      closeScoreScreen();
      updateCanvasSize();
      squareSize = 20;
      // create random start position for the snake
      [x, y] = randomPosition();
      // start on left half of the screen
      dx = 1;
      dy = 0;
      x/=2;
      snake = [{x: x, y: y}];
      keys=[];
      snakeColor = 0;
      foodColor = '#0f0';
      enableWrap = false;
      score = 0;
      pr = y;
      pu = undefined;
      pd = undefined;
      pl = undefined;
      
      snakeSize = 90;
      growthPerFood = 30;
      snakeSpeed = 1;
      snakeSpeedup = 0.3;
      precisionAngle = Math.PI/squareSize/3*snakeSpeed;
      xDiff = 1; yDiff = 0;
      tagertAngle = 0;
      // create a random position for the food
      [foodX, foodY] = randomPosition();

      playing = true;

      tick();
    }  

    var draw = function() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // draw the snake
      for (var i = snake.length-1; i >= 0; i--) {
        // create sin wave from i to snake.length
        var sin = Math.sin(i/30*Math.PI);
        ctx.fillStyle = 'hsl('+ (snakeColor + 30*sin) +',100%,50%)';
        ctx.fillRect(snake[i].x, snake[i].y, squareSize, squareSize);
      }
      snakeColor+=0.01;
      if(snakeColor > 60 && snakeColor < 180){ snakeColor+=1;}
      if(snakeColor > 360){ snakeColor -= 360;}

      ctx.fillStyle = foodColor;
      ctx.fillRect(foodX, foodY, squareSize, squareSize);

      if(showingMoup){
        if(showingMoup > 180){
          showingMoup = 0;
        } else {
          // transition across a bell curve
          var sin = Math.sin(showingMoup/180*Math.PI);
          ctx.fillStyle = 'hsl('+ (snakeColor + 30*sin) +',100%,50%)';

          ctx.fillRect(x -sin*3, y -sin*3, squareSize + sin*6, squareSize + sin*6);
          showingMoup+=8;
        }
      }
    }
    
    update = function() {
      moveSnake()
      checkGameOver();
      checkEat();
    }

    tick = function() {
      draw();
      update();
      if(playing){
        drawing = requestAnimationFrame(tick);
      }
    }

    closeScoreScreen =  function() {
      clearTimeout(scoreScreenOn);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      scoreScreenOn = playing = false;
      updates.innerHTML = startText;
    }

    gameOver = function () {      
      playing = false;
      canvas.classList.toggle('canvasBorder');
      deathSound();
      
      updates.style.display="flex";

      updates.innerText = 'Game Over\n\nScore: '+score+'\nHighscore: '+highScore+'\n\nPress space or enter to play again';
      scoreScreenOn = setTimeout(closeScoreScreen, 6000);
    }   

    checkGameOver = function () {

      if(!enableWrap){
        // if snake hits edge, gameover
        if (x+squareSize > canvas.width) {
          gameOver();
        }
        if (x < 0) {
          gameOver();
        }
        if (y+squareSize > canvas.height) {
          gameOver()
        }
        if (y < 0) {
          gameOver();
        }
      }

      // check if snake overlaps itself
      let snakeHeadDistance = Math.floor(3*squareSize/snakeSpeed);
      for (var i = snakeHeadDistance; i < snake.length; i++) {
        if (overlaps(x,y, snake[i].x , snake[i].y)) {
          // if it does, end the game
          gameOver();
          break;
        }
      }
    }

    overlaps = function(x, y, tx, ty) {
      return (x+squareSize > tx && x<tx+squareSize && y+squareSize>ty && y< ty+squareSize);
    }

    unableEffect = function() {
      moupSound();
      if(!showingMoup){
        showingMoup = 1;
      }
    }

    moveSnake = function() {
      if(!controlWithMouse){
        // change direction based on keys pressed
        if (keys[LEFT]){
          if(dx > 0.4){
            keys[LEFT] = false;
            unableEffect();
          } else if (!pr || (y+squareSize<pr || y> pr+squareSize)) {
            dx = -1;
            dy = 0;
            pl = y;
            pr = undefined;
            keys[LEFT] = false;
          }
        } else if (keys[UP]){
          if( dy > 0.4){
            keys[UP] = false;
            unableEffect();
          } else if (!pd || (x+squareSize<pd || x> pd+squareSize)) {
            dx = 0;
            dy = -1;
            pu = x;
            pd = undefined;
            keys[UP] = false;
          }
        } else if (keys[RIGHT]){
          if(dx < -0.3){
            keys[RIGHT] = false;
            unableEffect();
          } else if (!pl || (y+squareSize<pl || y>pl+squareSize)) {
            dx = 1;
            dy = 0;
            pr = y;
            pl = undefined;
            keys[RIGHT] = false;
          }
        } else if (keys[DOWN]){
          if(dy < -0.4){
            keys[DOWN] = false;
            unableEffect();
          } else if (!pu || (x+squareSize < pu || x> pu+squareSize)) {
            dx = 0;
            dy = 1;
            pd = x;
            pu = undefined;
            keys[DOWN] = false;
          }
        }        
      } else {
        if(mouseMovedSoTurn){
          if(mouseMove){
            // change direction based on mouse position
            xdiff = mx - x;
            ydiff = my - y;
            // find angle between current pos and mouse position
            targetAngle = Math.atan2(ydiff, xdiff);
            mouseMove = false;
          }

          // ensure new angle isn't more than 90 degrees from current angle
          // find angle of current direction
          let currentAngle = Math.atan2(dy, dx);
            
          let angleDiff = Math.abs(targetAngle - currentAngle);
          if(angleDiff> Math.PI){
            angleDiff = Math.PI*2 - angleDiff;
          }
          if(angleDiff < precisionAngle){
            // // set dx and dy to point to the mouse
            let distanceToMouse = Math.sqrt(xdiff*xdiff + ydiff*ydiff);
            dx = xdiff/distanceToMouse;
            dy = ydiff/distanceToMouse;
            mouseMovedSoTurn = false;
          }else{
                    
            if(targetAngle < currentAngle){
              targetAngle += 2* Math.PI;
            }
            // rotate currentAngle towards targetAngle
            let newAngle = 0;
            let turnAngle = precisionAngle;
            if(targetAngle - currentAngle > Math.PI){
              if(targetAngle - currentAngle < Math.PI*1.2 && (xdiff*xdiff + ydiff*ydiff)<100){
                turnAngle /= 8;
              }
              newAngle = currentAngle - turnAngle;
            }else{
              if(targetAngle - currentAngle > Math.PI*0.8 && (xdiff*xdiff + ydiff*ydiff)< 100){
                turnAngle /= 8;
              }
              
              newAngle = currentAngle + turnAngle;
              
            }

            dx = Math.cos(newAngle);
            dy = Math.sin(newAngle);
          }
        }
        // ensure that if keyboard controltakes over,
        // the user can't turn back on the spot
        
        if(dx>0){
          pr = y;
          pl = undefined;
        }else{
          pl = y;
          pr = undefined;
        }
        if(dy>0){
          pd = x;
          pu = undefined;
        }else{
          pu = x;
          pd = undefined;
        }
      }

      x += dx * snakeSpeed;
      y += dy * snakeSpeed;
      if(enableWrap){
        // if snake hits edge, wrap around
        if (x > canvas.width) {
          x = 0;
        }
        if (x < 0) {
          x = canvas.width;
        }
        if (y > canvas.height) {
          y = 0;
        }
        if (y < 0) {
          y = canvas.height;
        }
      }

      // move the snake by adding the current position to the front of the array
      snake.unshift({x: x, y: y});
      // and removing the last item from the array if the snake size is greater than snakeLength
      if (snake.length > snakeSize) {
        snake.pop();
      }
    }

    // a function to generate a happy sound
    happySound = function () {
      happySounds[Math.floor(Math.random() * happySounds.length)].play();
    }

    // a function to generate a death sound
    deathSound = function () {
      deathSounds[Math.floor(Math.random() * deathSounds.length)].play();
    }

    // a function to generate a moup sound
    moupSound = function () {
      moupSounds[Math.floor(Math.random() * moupSounds.length)].play();
    }

    checkEat = function() {
      // check if the snake overlaps the food
      if (overlaps(x, y, foodX, foodY)) {
        happySound();
        // if it does, create a new food
        let newRandomPosition;
        for(let i = 0; i < 100; i++){
          newRandomPosition = randomPosition();
          if(!snake.some(p=>overlaps(p.x, p.y, newRandomPosition[0], newRandomPosition[1]))){
            break;
          }
        }
        [foodX, foodY] = newRandomPosition;
        // and increase the snake's size
        snakeSize+=growthPerFood;
        score += snakeSize;
        if(score > highScore){
          highScore = score;
        }
        snakeSpeed+=snakeSpeedup;
        // precisionAngle = Math.PI/squareSize/3*snakeSpeed;
        let [gx,gy] = updateCanvasSize();
        snake.forEach(p=>{p.x+=gx; p.y+=gy;});
        foodX+=gx;
        foodY+=gy;
        x+=gx;
        y+=gy;
        pu+=gx;
        pd+=gx;
        pl+=gy;
        pr+=gy;
      
      }
    }

    randomPosition = function() {
      return [
        Math.floor(Math.random() * (canvas.width - squareSize)),
        Math.floor(Math.random() * (canvas.height - squareSize))
      ];
    } 

  </script>
</body>
</html>